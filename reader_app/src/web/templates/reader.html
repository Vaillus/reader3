<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <!-- Rangy Libraries for manual highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/rangy/1.3.1/rangy-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/rangy/1.3.1/rangy-classapplier.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/rangy/1.3.1/rangy-highlighter.min.js"></script>
    <style>
        /* Layout */
        body { margin: 0; padding: 0; display: flex; height: 100vh; overflow: hidden; font-family: "Georgia", serif; background: #fff; }

        /* Sidebar - Structure Flex pour Header Fixe */
        #sidebar { 
            width: 300px; 
            background: #f8f9fa; 
            border-right: 1px solid #e9ecef; 
            display: flex; 
            flex-direction: column; 
            flex-shrink: 0; 
            height: 100vh;
        }
        
        /* Header Fixe de la Sidebar */
        .sidebar-header-fixed {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            flex-shrink: 0;
            z-index: 10;
        }

        /* Zone TOC qui d√©file ind√©pendamment */
        .sidebar-toc-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .nav-home { display: block; margin-bottom: 12px; color: #6c757d; text-decoration: none; font-family: -apple-system, sans-serif; font-size: 0.85em; font-weight: 500; transition: color 0.2s; }
        .nav-home:hover { color: #3498db; }
        
        .book-title { font-family: -apple-system, sans-serif; font-weight: bold; color: #212529; margin-bottom: 15px; line-height: 1.3; }

        /* Outils int√©gr√©s */
        .sidebar-tools {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }

        .tool-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            cursor: pointer;
            font-family: -apple-system, sans-serif;
            font-size: 0.9em;
            color: #495057;
            transition: all 0.2s;
            box-shadow: 0 1px 2px rgba(0,0,0,0.03);
        }

        .tool-btn:hover {
            background: #e9ecef;
            border-color: #ced4da;
            color: #000;
        }

        /* √âtat actif pour montrer quel panneau est ouvert */
        .tool-btn.active {
            background: #e7f1ff;
            color: #0d6efd;
            border-color: #0d6efd;
        }

        /* TOC Tree */
        ul.toc-list { list-style: none; padding-left: 0; margin: 0; }
        ul.toc-list ul { padding-left: 20px; } /* Indent children */
        li.toc-item { margin-bottom: 8px; }
        a.toc-link { text-decoration: none; color: #495057; font-size: 0.95em; display: block; padding: 4px 0; line-height: 1.4; }
        a.toc-link:hover { color: #000; text-decoration: underline; }
        a.toc-link.active { color: #d63384; font-weight: bold; }

        /* Main Content */
        #main { flex-grow: 1; overflow-y: auto; position: relative; scroll-behavior: smooth; }
        .content-container { max-width: 700px; margin: 0 auto; padding: 60px 40px; line-height: 1.8; font-size: 1.15em; color: #212529; }

        /* Panels Container */
        #panels-container {
            display: flex;
            flex-direction: row;
        }

        /* Note Panel */
        #notes-panel {
            width: 0;
            background: #fff;
            border-left: 1px solid #dee2e6;
            transition: width 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #notes-panel.open { width: 400px; }

        /* Chat Panel */
        #chat-panel {
            width: 0;
            background: #fff;
            border-left: 1px solid #dee2e6;
            transition: width 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #chat-panel.open { width: 400px; }
        
        .chat-header {
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            font-family: -apple-system, sans-serif;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .chat-message {
            max-width: 85%;
            padding: 12px 16px;
            border-radius: 12px;
            line-height: 1.5;
            word-wrap: break-word;
        }
        
        .chat-message.user-message {
            align-self: flex-end;
            background: #3498db;
            color: white;
        }
        
        .chat-message.assistant-message {
            align-self: flex-start;
            background: #f1f3f5;
            color: #212529;
        }
        
        .message-content {
            white-space: pre-wrap;
        }
        
        .chat-input-container {
            padding: 15px;
            border-top: 1px solid #dee2e6;
            background: #f8f9fa;
        }
        
        .chat-input-form {
            display: flex;
            gap: 8px;
        }
        
        .chat-input {
            flex-grow: 1;
            padding: 10px 15px;
            border: 1px solid #dee2e6;
            border-radius: 20px;
            font-family: -apple-system, sans-serif;
            font-size: 0.95em;
            outline: none;
        }
        
        .chat-input:focus {
            border-color: #3498db;
        }
        
        .chat-send-btn {
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-family: -apple-system, sans-serif;
            font-weight: bold;
        }
        
        .chat-send-btn:hover {
            background: #2980b9;
        }
        
        .chat-send-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        /* Context Chips */
        .context-chips {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .context-chip {
            font-size: 0.85em;
            padding: 4px 10px;
            border-radius: 15px;
            border: 1px solid #dee2e6;
            background: #f8f9fa;
            color: #6c757d;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .context-chip.active {
            background: #e7f1ff;
            color: #0d6efd;
            border-color: #0d6efd;
        }

        .context-chip:hover {
            background: #e9ecef;
        }

        .context-chip.snippet-chip {
            background: #fff3cd;
            color: #856404;
            border-color: #ffc107;
        }

        .context-chip.snippet-chip .remove-snippet {
            margin-left: 5px;
            cursor: pointer;
            font-weight: bold;
            opacity: 0.7;
        }

        .context-chip.snippet-chip .remove-snippet:hover {
            opacity: 1;
        }

        /* Floating selection menu */
        .selection-menu {
            position: fixed;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 4px;
            z-index: 10000;
            display: none;
            font-family: -apple-system, sans-serif;
            pointer-events: auto;
        }

        .selection-menu button {
            padding: 6px 12px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.9em;
            color: #495057;
            display: block;
            width: 100%;
            text-align: left;
        }

        .selection-menu button:hover {
            background: #f8f9fa;
        }

        .quote-indicator {
            padding: 8px 12px;
            background: #fff3cd;
            border-left: 3px solid #ffc107;
            margin-bottom: 10px;
            font-size: 0.9em;
            font-style: italic;
            border-radius: 4px;
        }
        
        .quote-indicator .remove-quote {
            float: right;
            cursor: pointer;
            font-weight: bold;
            color: #666;
        }
        
        .add-chapter-btn, .add-notes-btn {
            padding: 6px 12px;
            margin: 5px 0;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            font-family: -apple-system, sans-serif;
        }
        
        .add-chapter-btn:hover, .add-notes-btn:hover {
            background: #e9ecef;
        }

        #chat-history-list {
            max-height: 200px;
            overflow-y: auto;
        }

        #chat-history-list div {
            transition: background-color 0.2s;
        }
        
        .notes-header {
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            font-family: -apple-system, sans-serif;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .notes-editor {
            flex-grow: 1;
            padding: 20px;
            border: none;
            resize: none;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.5;
            outline: none;
        }
        

        /* Content Styling (Basic normalization for the book HTML) */
        .book-content img { max-width: 100%; height: auto; display: block; margin: 20px auto; }
        .book-content h1, .book-content h2, .book-content h3 { font-family: -apple-system, sans-serif; margin-top: 1.5em; color: #333; }
        .book-content p { margin-bottom: 1.5em; text-align: justify; }
        
        /* Highlights */
        .book-content .highlight { 
            background-color: #fff3cd; 
            padding: 2px 0; 
            border-bottom: 2px solid #ffc107;
            cursor: help;
        }
        .book-content .highlight:hover {
            background-color: #ffe69c;
        }
        
        /* Manual highlights (created via Rangy) - SAME STYLE AS KOBO */
        .manual-highlight {
            background-color: #fff3cd;
            padding: 2px 0;
            border-bottom: 2px solid #ffc107;
            cursor: pointer;
        }
        .manual-highlight:hover {
            background-color: #ffe69c;
        }

        /* Navigation Footer */
        .chapter-nav { display: flex; justify-content: space-between; margin-top: 60px; padding-top: 20px; border-top: 1px solid #eee; font-family: -apple-system, sans-serif; }
        .nav-btn { text-decoration: none; color: #3498db; font-weight: bold; padding: 10px 20px; border: 1px solid #3498db; border-radius: 4px; transition: all 0.2s; }
        .nav-btn:hover { background: #3498db; color: white; }
        .nav-btn.disabled { opacity: 0.5; pointer-events: none; border-color: #ccc; color: #ccc; }

        /* Dark Mode Styles */
        body.dark-mode {
            background: #1a1a1a;
            color: #e0e0e0;
        }

        body.dark-mode #sidebar {
            background: #2d2d2d;
            border-right-color: #404040;
        }

        body.dark-mode .sidebar-header-fixed {
            background: #2d2d2d;
            border-bottom-color: #404040;
        }

        body.dark-mode .sidebar-toc-content {
            background: #2d2d2d;
        }

        body.dark-mode .nav-home {
            color: #a0a0a0;
        }

        body.dark-mode .nav-home:hover {
            color: #5dade2;
        }

        body.dark-mode .book-title {
            color: #e0e0e0;
        }

        body.dark-mode .tool-btn {
            background: #3a3a3a;
            border-color: #505050;
            color: #d0d0d0;
        }

        body.dark-mode .tool-btn:hover {
            background: #4a4a4a;
            border-color: #606060;
            color: #fff;
        }

        body.dark-mode .tool-btn.active {
            background: #1e3a5f;
            color: #5dade2;
            border-color: #5dade2;
        }

        body.dark-mode a.toc-link {
            color: #c0c0c0;
        }

        body.dark-mode a.toc-link:hover {
            color: #fff;
        }

        body.dark-mode a.toc-link.active {
            color: #ff6b9d;
        }

        body.dark-mode #main {
            background: #1a1a1a;
        }

        body.dark-mode .content-container {
            color: #e0e0e0;
        }

        body.dark-mode .book-content h1,
        body.dark-mode .book-content h2,
        body.dark-mode .book-content h3 {
            color: #f0f0f0;
        }

        body.dark-mode .book-content p {
            color: #e0e0e0;
        }

        body.dark-mode #chat-panel,
        body.dark-mode #notes-panel {
            background: #2d2d2d;
            border-left-color: #404040;
        }

        body.dark-mode .chat-header,
        body.dark-mode .notes-header {
            background: #3a3a3a;
            border-bottom-color: #505050;
            color: #e0e0e0;
        }

        body.dark-mode .chat-messages {
            background: #2d2d2d;
        }

        body.dark-mode .chat-message.assistant-message {
            background: #3a3a3a;
            color: #e0e0e0;
        }

        body.dark-mode .chat-input-container {
            background: #3a3a3a;
            border-top-color: #505050;
        }

        body.dark-mode .chat-input {
            background: #2d2d2d;
            border-color: #505050;
            color: #e0e0e0;
        }

        body.dark-mode .chat-input:focus {
            border-color: #5dade2;
        }

        body.dark-mode .notes-editor {
            background: #2d2d2d;
            color: #e0e0e0;
        }

        body.dark-mode .chapter-nav {
            border-top-color: #404040;
        }

        body.dark-mode .nav-btn {
            color: #5dade2;
            border-color: #5dade2;
        }

        body.dark-mode .nav-btn:hover {
            background: #5dade2;
            color: #1a1a1a;
        }

        body.dark-mode .nav-btn.disabled {
            border-color: #505050;
            color: #666;
        }

        body.dark-mode .selection-menu {
            background: #3a3a3a;
            border-color: #505050;
        }

        body.dark-mode .selection-menu button {
            color: #e0e0e0;
        }

        body.dark-mode .selection-menu button:hover {
            background: #4a4a4a;
        }

        body.dark-mode .context-chip {
            background: #3a3a3a;
            border-color: #505050;
            color: #c0c0c0;
        }

        body.dark-mode .context-chip.active {
            background: #1e3a5f;
            color: #5dade2;
            border-color: #5dade2;
        }

        body.dark-mode .context-chip:hover {
            background: #4a4a4a;
        }

        body.dark-mode .quote-indicator {
            background: #3a3a3a;
            border-left-color: #ffc107;
            color: #e0e0e0;
        }

        /* Highlights en mode nuit - couleurs plus visibles */
        body.dark-mode .book-content .highlight {
            background-color: #4a3a00;
            border-bottom-color: #ffc107;
            color: #ffd700;
        }

        body.dark-mode .book-content .highlight:hover {
            background-color: #5a4a00;
        }

        body.dark-mode .manual-highlight {
            background-color: #4a3a00;
            border-bottom-color: #ffc107;
            color: #ffd700;
        }

        body.dark-mode .manual-highlight:hover {
            background-color: #5a4a00;
        }

    </style>
</head>
<body>

    <!-- SIDEBAR -->
    <div id="sidebar">
        <div class="sidebar-header-fixed">
            <a href="/" class="nav-home">‚Üê Library</a>
            <div class="book-title">{{ book.metadata.title }}</div>
            
            <div class="sidebar-tools">
                <button class="tool-btn" id="btn-chat" onclick="toggleChat()">
                    <span>üí¨</span> Chat
                </button>
                <button class="tool-btn" id="btn-notes" onclick="toggleNotes()">
                    <span>üìù</span> Notes
                </button>
                <button class="tool-btn" id="btn-dark-mode" onclick="toggleDarkMode()">
                    <span id="dark-mode-icon">üåô</span> <span id="dark-mode-text">Nuit</span>
                </button>
            </div>
        </div>

        <div class="sidebar-toc-content">
            <!-- Recursive Macro for TOC -->
            {% macro render_toc(items) %}
                <ul class="toc-list">
                {% for item in items %}
                    <li class="toc-item">
                        <!--
                            Matching Logic:
                            If the TOC item filename matches the current chapter filename, mark active.
                            Ideally we match spine indices, but Reader 3 TOC maps to filenames.
                            We use a simple hash matching logic here.
                        -->
                        {% set is_active = current_chapter.href == item.file_href %}

                        <!--
                           We need to find which linear chapter index (0, 1, 2) corresponds
                           to this TOC entry file.
                           Since that's hard to calculate in Jinja, we just link to the
                           file anchor. BUT, to make our linear navigation work, we
                           rely on the fact that the user is currently reading 'chapter_index'.

                           Ideally, clicking a TOC link should find the 'index' of that file.
                           For simplicity in this version: We link to the 'href' (filename)
                           and let JavaScript or Backend handle it?

                           Actually, let's just link to the file. The browser interprets #anchors.
                           However, our router uses /read/book/INDEX.

                           SIMPLE FIX: We won't link the TOC to the route index in this simple version
                           unless we build a map. We will visually show structure,
                           but rely on "Previous/Next" for linear reading.

                           BETTER FIX: Use JavaScript to match filenames.
                        -->
                        <a href="#" onclick="findAndGo('{{ item.file_href }}')"
                           class="toc-link {% if is_active %}active{% endif %}">
                            {{ item.title }}
                        </a>

                        {% if item.children %}
                            {{ render_toc(item.children) }}
                        {% endif %}
                    </li>
                {% endfor %}
                </ul>
            {% endmacro %}

            {{ render_toc(book.toc) }}
        </div>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main">
        <div class="content-container">
            <div class="book-content">
                {{ current_chapter.content | safe }}
            </div>

            <div class="chapter-nav">
                {% if prev_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ prev_idx }}" class="nav-btn">‚Üê Previous</a>
                {% else %}
                    <span class="nav-btn disabled">‚Üê Previous</span>
                {% endif %}

                <span style="color: #999; padding: 10px;">
                    Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                </span>

                {% if next_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ next_idx }}" class="nav-btn">Next ‚Üí</a>
                {% else %}
                    <span class="nav-btn disabled">Next ‚Üí</span>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- PANELS CONTAINER -->
    <div id="panels-container">
        <!-- CHAT PANEL -->
        <div id="chat-panel">
            <div class="chat-header">
                <div style="display:flex; align-items:center; gap:10px;">
                    <span>Chat</span>
                    <span id="chat-session-title" style="font-weight:normal; font-size:0.8em; opacity:0.7;"></span>
                </div>
                <div>
                    <button onclick="toggleHistory()" class="add-chapter-btn" title="Historique">üìú</button>
                    <button onclick="startNewChat()" class="add-chapter-btn" title="Nouveau Chat">‚ûï</button>
                </div>
            </div>
            
            <!-- Overlay pour l'historique -->
            <div id="chat-history-list" style="display:none; background:#f8f9fa; border-bottom:1px solid #ddd; max-height:200px; overflow-y:auto;">
                <!-- Les sessions seront inject√©es ici -->
            </div>
            
            <div class="chat-messages" id="chat-messages">
                <!-- Messages will be added here via HTMX -->
            </div>
            <div class="chat-input-container">
                <div id="quote-indicator" class="quote-indicator" style="display: none;">
                    <span id="quote-text"></span>
                    <span class="remove-quote" onclick="removeQuote()">√ó</span>
                </div>
                
                <div class="context-chips" id="context-chips">
                    <div class="context-chip active" id="chip-chapter" onclick="toggleContext('chapter')">
                        <span>üìÑ Chapitre</span>
                    </div>
                    <div class="context-chip" id="chip-notes" onclick="toggleContext('notes')">
                        <span>üìù Mes Notes</span>
                    </div>
                    <!-- Snippet chips will be added here dynamically -->
                </div>

                <form class="chat-input-form" 
                      onsubmit="return submitChatForm(event)">
                    <input type="text" 
                           id="chat-input" 
                           class="chat-input" 
                           placeholder="Pose une question sur ce chapitre..."
                           required>
                    <button type="submit" class="chat-send-btn">Envoyer</button>
                </form>
            </div>
        </div>

        <!-- NOTES PANEL -->
        <div id="notes-panel">
            <div class="notes-header">
                <span>Chapter Notes (Markdown)</span>
                <span id="save-status" style="font-size: 0.8em; color: #999;">Synced</span>
            </div>
            <textarea id="note-editor" class="notes-editor" placeholder="Write your notes here... they will sync to Obsidian.">{{ note_content }}</textarea>
        </div>
    </div>

    <script>
        // Helper to map TOC filenames to Spine Indices
        // Pass the spine data from python to JS
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ ch.order }},
            {% endfor %}
        };

        function findAndGo(filename) {
            // The TOC usually has specific filenames e.g. "text/part001.html"
            // Sometimes it has anchors "text/part001.html#header"
            // We strip the anchor to find the page index
            const cleanFile = filename.split('#')[0];
            const anchor = filename.split('#')[1];

            const idx = spineMap[cleanFile];

            if (idx !== undefined) {
                let url = "/read/{{ book_id }}/" + idx;
                // If there was an anchor, we could try to scroll to it,
                // but simple page loads often lose anchor position without extra JS.
                // Let's just go to the page.
                window.location.href = url;
            } else {
                console.log("Could not find index for", filename);
            }
        }

        // --- CHAT LOGIC ---
        const chatPanel = document.getElementById('chat-panel');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const quoteIndicator = document.getElementById('quote-indicator');
        const quoteText = document.getElementById('quote-text');
        // Note: quoted-text-input and conversation-history-input were removed from form
        // We use selectedText variable directly instead
        let conversationHistory = [];
        let selectedText = null;
        let selectedSnippets = []; // Array of {id, text, preview}
        let snippetCounter = 0;
        let currentSelection = null;
        let currentSessionId = null; // Variable d'√©tat pour la session active

        // --- DARK MODE LOGIC ---
        function toggleDarkMode() {
            const body = document.body;
            const isDark = body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', isDark);
            
            // Mise √† jour de l'ic√¥ne et du texte
            const icon = document.getElementById('dark-mode-icon');
            const text = document.getElementById('dark-mode-text');
            if (icon && text) {
                if (isDark) {
                    icon.textContent = '‚òÄÔ∏è';
                    text.textContent = 'Jour';
                } else {
                    icon.textContent = 'üåô';
                    text.textContent = 'Nuit';
                }
            }
        }

        // Load dark mode preference
        if (localStorage.getItem('darkMode') === 'true') {
            document.body.classList.add('dark-mode');
            const icon = document.getElementById('dark-mode-icon');
            const text = document.getElementById('dark-mode-text');
            if (icon && text) {
                icon.textContent = '‚òÄÔ∏è';
                text.textContent = 'Jour';
            }
        }

        // Load chat preference
        if (localStorage.getItem('chatPanelOpen') === 'true') {
            chatPanel.classList.add('open');
            const btnChat = document.getElementById('btn-chat');
            if (btnChat) btnChat.classList.add('active');
        }

        function toggleChat() {
            const wasOpen = chatPanel.classList.contains('open');
            chatPanel.classList.toggle('open');
            localStorage.setItem('chatPanelOpen', chatPanel.classList.contains('open'));
            
            // Mise √† jour visuelle du bouton
            const btn = document.getElementById('btn-chat');
            if (btn) {
                if (chatPanel.classList.contains('open')) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            }
            
            // Scroll to bottom when opening
            if (!wasOpen && chatPanel.classList.contains('open')) {
                setTimeout(() => scrollChatToBottom(), 100);
            }
        }

        function scrollChatToBottom() {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // --- SESSION MANAGEMENT ---
        async function loadChatHistoryList() {
            const listContainer = document.getElementById('chat-history-list');
            try {
                const bookId = encodeURIComponent('{{ book_id }}');
                const chapterIndex = encodeURIComponent('{{ chapter_index }}');
                const res = await fetch(`/api/chat/sessions/${bookId}/${chapterIndex}`);
                const data = await res.json();
                
                if (data.sessions.length === 0) {
                    listContainer.innerHTML = '<div style="padding:10px; font-style:italic; color:#666;">Aucun historique</div>';
                    return;
                }

                listContainer.innerHTML = data.sessions.map(s => `
                    <div onclick="loadSession('${s.id}')" style="padding:8px 15px; cursor:pointer; border-bottom:1px solid #eee;" onmouseover="this.style.background='#fff'" onmouseout="this.style.background='transparent'">
                        <div style="font-weight:bold; font-size:0.9em;">${s.title}</div>
                        <div style="font-size:0.75em; color:#666;">${new Date(s.date).toLocaleDateString('fr-FR')} ${new Date(s.date).toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'})} - ${s.preview || 'Nouvelle conversation'}</div>
                    </div>
                `).join('');
            } catch (e) {
                console.error("Erreur chargement historique", e);
                listContainer.innerHTML = '<div style="padding:10px; color:red;">Erreur lors du chargement</div>';
            }
        }

        function toggleHistory() {
            const list = document.getElementById('chat-history-list');
            if (list.style.display === 'none') {
                loadChatHistoryList();
                list.style.display = 'block';
            } else {
                list.style.display = 'none';
            }
        }

        async function startNewChat() {
            // R√©initialiser l'UI
            document.getElementById('chat-messages').innerHTML = '';
            conversationHistory = [];
            currentSessionId = null;
            document.getElementById('chat-session-title').textContent = '';
            document.getElementById('chat-history-list').style.display = 'none';
            
            // Optionnel : Forcer la cr√©ation imm√©diate d'ID
            try {
                const bookId = encodeURIComponent('{{ book_id }}');
                const chapterIndex = encodeURIComponent('{{ chapter_index }}');
                const res = await fetch(`/api/chat/sessions/new?book_id=${bookId}&chapter_index=${chapterIndex}`, { method: 'POST' });
                const data = await res.json();
                currentSessionId = data.id;
                document.getElementById('chat-session-title').textContent = data.title;
            } catch (e) {
                console.error("Erreur cr√©ation nouvelle session", e);
            }
        }

        async function loadSession(sessionId) {
            try {
                const bookId = encodeURIComponent('{{ book_id }}');
                const res = await fetch(`/api/chat/session/${bookId}/${sessionId}`);
                const data = await res.json();
                
                currentSessionId = data.id;
                conversationHistory = [];
                const container = document.getElementById('chat-messages');
                container.innerHTML = '';

                // Reconstituer l'interface
                data.messages.forEach(msg => {
                    const div = document.createElement('div');
                    div.className = `chat-message ${msg.role === 'user' ? 'user-message' : 'assistant-message'}`;
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'message-content';
                    // Convert newlines to <br> for display
                    contentDiv.innerHTML = msg.content.replace(/\n/g, '<br>');
                    div.appendChild(contentDiv);
                    container.appendChild(div);
                    
                    // Reconstruire l'historique pour le contexte LLM
                    conversationHistory.push({ role: msg.role, content: msg.content });
                });

                document.getElementById('chat-session-title').textContent = data.title;
                document.getElementById('chat-history-list').style.display = 'none';
                scrollChatToBottom();
                
                // Update conversation history for LLM context
                updateConversationHistory();
            } catch (e) {
                console.error("Erreur chargement session", e);
                alert('Erreur lors du chargement de la session');
            }
        }
        // ---------------------------

        function isUserAtBottom() {
            // Check if user is near the bottom (within 50px threshold)
            const threshold = 50;
            const position = chatMessages.scrollTop + chatMessages.clientHeight;
            const height = chatMessages.scrollHeight;
            return height - position <= threshold;
        }

        function clearChatInput() {
            if (chatInput) chatInput.value = '';
            removeQuote();
            scrollChatToBottom();
            // Note: updateConversationHistory() is called separately after messages are added
        }

        function removeQuote() {
            if (quoteIndicator) quoteIndicator.style.display = 'none';
            selectedText = null;
        }

        function addQuoteToChat(text) {
            selectedText = text;
            if (quoteText) quoteText.textContent = `"${text.substring(0, 100)}${text.length > 100 ? '...' : ''}"`;
            if (quoteIndicator) quoteIndicator.style.display = 'block';
        }

        // Gestion des Chips
        let contextState = {
            chapter: true,
            notes: false
        };

        function toggleContext(type) {
            contextState[type] = !contextState[type];
            const chip = document.getElementById(`chip-${type}`);
            if (contextState[type]) {
                chip.classList.add('active');
            } else {
                chip.classList.remove('active');
            }
        }

        function updateConversationHistory() {
            // Extract messages from the DOM
            const messages = chatMessages.querySelectorAll('.chat-message');
            conversationHistory = [];
            messages.forEach(msg => {
                const isUser = msg.classList.contains('user-message');
                const content = msg.querySelector('.message-content').textContent;
                conversationHistory.push({
                    role: isUser ? 'user' : 'assistant',
                    content: content
                });
            });
        }

        async function submitChatForm(event) {
            event.preventDefault();
            const form = event.target;
            const message = chatInput.value.trim();
            if (!message) return false;

            // Prepare JSON body
            const body = {
                session_id: currentSessionId,
                message: message,
                conversation_history: conversationHistory,
                quoted_text: selectedText || null,
                include_chapter: contextState.chapter,
                include_notes: contextState.notes,
                // Send current editor content to ensure fresh notes
                current_notes: noteEditor.value,
                // Send snippets
                snippets: selectedSnippets.map(s => s.text)
            };

            // Disable send button while processing
            const sendBtn = form.querySelector('button[type="submit"]');
            const originalBtnText = sendBtn.textContent;
            sendBtn.disabled = true;
            sendBtn.textContent = 'Envoi...';

            // Encode parameters to handle special characters in book_id
            const bookId = encodeURIComponent('{{ book_id }}');
            const chapterIndex = encodeURIComponent('{{ chapter_index }}');
            
            // Create user message element
            const escapedUserMessage = message.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            const userMessageDiv = document.createElement('div');
            userMessageDiv.className = 'chat-message user-message';
            userMessageDiv.innerHTML = `<div class="message-content">${escapedUserMessage}</div>`;
            chatMessages.appendChild(userMessageDiv);
            
            // Create assistant message element (will be updated as chunks arrive)
            const assistantMessageDiv = document.createElement('div');
            assistantMessageDiv.className = 'chat-message assistant-message';
            const assistantContentDiv = document.createElement('div');
            assistantContentDiv.className = 'message-content';
            assistantMessageDiv.appendChild(assistantContentDiv);
            chatMessages.appendChild(assistantMessageDiv);
            
            // Scroll to bottom
            scrollChatToBottom();
            
            try {
                const response = await fetch(`/chat/send?book_id=${bookId}&chapter_index=${chapterIndex}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server error: ${response.status} - ${errorText}`);
                }
                
                // Read the stream
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let assistantText = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    
                    // Process complete SSE messages (lines ending with \n\n)
                    const lines = buffer.split('\n\n');
                    buffer = lines.pop() || ''; // Keep incomplete line in buffer
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = JSON.parse(line.slice(6));
                            
                            if (data.type === 'chunk') {
                                // Check if user is at bottom BEFORE updating content
                                const shouldScroll = isUserAtBottom();
                                
                                // Append chunk to assistant message
                                assistantText += data.content;
                                // Convert newlines to <br> for display
                                const formattedText = assistantText.replace(/\n/g, '<br>');
                                assistantContentDiv.innerHTML = formattedText;
                                
                                // Only scroll if user was already at bottom
                                if (shouldScroll) {
                                    scrollChatToBottom();
                                }
                            } else if (data.type === 'error') {
                                assistantContentDiv.innerHTML = `<span style="color: red;">${data.content}</span>`;
                                scrollChatToBottom();
                                throw new Error(data.content);
                            } else if (data.type === 'assistant_end') {
                                // Streaming complete
                            } else if (data.type === 'session_init') {
                                // New session created, store the ID
                                currentSessionId = data.id;
                                // Load session title
                                if (currentSessionId) {
                                    const bookId = encodeURIComponent('{{ book_id }}');
                                    fetch(`/api/chat/session/${bookId}/${currentSessionId}`)
                                        .then(res => res.json())
                                        .then(sessionData => {
                                            document.getElementById('chat-session-title').textContent = sessionData.title;
                                        })
                                        .catch(e => console.error("Error loading session title", e));
                                }
                            }
                        }
                    }
                }
                
                // Update conversation history
                updateConversationHistory();
                
                // Clear input, snippets, and scroll
                clearChatInput();
                // Clear snippets after sending
                selectedSnippets.forEach(s => {
                    const chip = document.getElementById(s.id);
                    if (chip) chip.remove();
                });
                selectedSnippets = [];
                
                // Re-enable send button
                sendBtn.disabled = false;
                sendBtn.textContent = originalBtnText;
                
            } catch (error) {
                console.error('Chat error:', error);
                if (assistantContentDiv) {
                    assistantContentDiv.innerHTML = `<span style="color: red;">Erreur: ${error.message}</span>`;
                } else {
                    alert('Erreur lors de l\'envoi du message: ' + error.message);
                }
                // Re-enable send button on error
                sendBtn.disabled = false;
                sendBtn.textContent = originalBtnText;
            }

            return false;
        }

        // Handle text selection for snippets
        document.addEventListener('mouseup', (e) => {
            // Don't interfere with clicks on the selection menu itself
            const menu = document.getElementById('selection-menu');
            if (menu && menu.contains(e.target)) {
                return;
            }
            
            // Small delay to ensure selection is complete
            setTimeout(() => {
                const selection = window.getSelection();
                const selectedTextContent = selection.toString().trim();
                
                // Hide menu if clicking outside and no selection
                if (selectedTextContent.length === 0) {
                    hideSelectionMenu();
                    return;
                }
                
                // Only show menu if selection is in book content (not in chat or notes)
                const bookContent = document.querySelector('.book-content');
                let isInBookContent = false;
                
                if (bookContent && selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    // Check if the range intersects with book content
                    isInBookContent = bookContent.contains(range.commonAncestorContainer) || 
                                     bookContent.contains(range.startContainer) ||
                                     bookContent.contains(range.endContainer);
                }
                
                if (isInBookContent && selectedTextContent.length > 0) {
                    // Store selection info (cloner le range pour √©viter qu'il soit invalid√©)
                    const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
                    currentSelection = {
                        text: selectedTextContent,
                        range: range ? range.cloneRange() : null
                    };
                    
                    // Show floating menu near selection
                    if (currentSelection.range) {
                        const rect = currentSelection.range.getBoundingClientRect();
                        showSelectionMenu(rect);
                    }
                } else {
                    hideSelectionMenu();
                }
                
                // Keep old behavior for quoted_text (for non-book content)
                if (selectedTextContent.length < 500) {
                    selectedText = selectedTextContent;
                }
            }, 10);
        });
        
        // Hide menu when clicking elsewhere
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('selection-menu');
            if (menu && !menu.contains(e.target) && e.target.id !== 'selection-menu') {
                hideSelectionMenu();
            }
        });

        function showSelectionMenu(rect) {
            // Create menu if it doesn't exist
            let menu = document.getElementById('selection-menu');
            if (!menu) {
                menu = document.createElement('div');
                menu.id = 'selection-menu';
                menu.className = 'selection-menu';
                menu.innerHTML = `
                    <button onclick="addSnippetFromSelection()">üìé Ajouter au contexte</button>
                    <button onclick="highlightFromSelection()">‚úèÔ∏è Surligner</button>
                `;
                document.body.appendChild(menu);
            }
            
            menu.style.display = 'block';
            menu.style.left = (rect.left + window.scrollX) + 'px';
            menu.style.top = (rect.bottom + window.scrollY + 5) + 'px';
        }

        function hideSelectionMenu() {
            const menu = document.getElementById('selection-menu');
            if (menu) {
                menu.style.display = 'none';
            }
            currentSelection = null;
        }

        function addSnippetFromSelection() {
            if (!currentSelection || !currentSelection.text) return;
            
            const snippetId = `snippet-${snippetCounter++}`;
            const snippetText = currentSelection.text;
            const preview = snippetText.length > 50 
                ? snippetText.substring(0, 50) + '...' 
                : snippetText;
            
            selectedSnippets.push({
                id: snippetId,
                text: snippetText,
                preview: preview
            });
            
            // Add chip to UI
            addSnippetChip(snippetId, preview);
            
            // Hide menu and clear selection
            hideSelectionMenu();
            window.getSelection().removeAllRanges();
        }

        function addSnippetChip(snippetId, preview) {
            const chipsContainer = document.getElementById('context-chips');
            const chip = document.createElement('div');
            chip.className = 'context-chip snippet-chip';
            chip.id = snippetId;
            chip.innerHTML = `
                <span>üìé ${preview}</span>
                <span class="remove-snippet" onclick="removeSnippet('${snippetId}')">√ó</span>
            `;
            chipsContainer.appendChild(chip);
        }

        function removeSnippet(snippetId) {
            // Remove from array
            selectedSnippets = selectedSnippets.filter(s => s.id !== snippetId);
            
            // Remove chip from UI
            const chip = document.getElementById(snippetId);
            if (chip) {
                chip.remove();
            }
        }

        // Add keyboard shortcut to add snippet to context (Ctrl+Q or Cmd+Q)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'q') {
                e.preventDefault();
                const selection = window.getSelection();
                const selectedTextContent = selection.toString().trim();
                
                if (selectedTextContent.length > 0) {
                    // Check if selection is in book content
                    const bookContent = document.querySelector('.book-content');
                    if (bookContent && bookContent.contains(selection.anchorNode)) {
                        // Add as snippet
                        const snippetId = `snippet-${snippetCounter++}`;
                        const snippetText = selectedTextContent;
                        const preview = snippetText.length > 50 
                            ? snippetText.substring(0, 50) + '...' 
                            : snippetText;
                        
                        selectedSnippets.push({
                            id: snippetId,
                            text: snippetText,
                            preview: preview
                        });
                        
                        // Add chip to UI
                        addSnippetChip(snippetId, preview);
                        
                        // Clear selection
                        selection.removeAllRanges();
                        
                        // Focus chat input
                        if (chatInput) chatInput.focus();
                    } else {
                        // Fallback: use old quote behavior for non-book content
                        if (selectedTextContent.length < 500) {
                            addQuoteToChat(selectedTextContent);
                            if (chatInput) chatInput.focus();
                        }
                    }
                }
            }
        });

        // Update conversation history when HTMX adds new messages
        document.body.addEventListener('htmx:afterSwap', (e) => {
            if (e.detail.target.id === 'chat-messages') {
                updateConversationHistory();
            }
        });

        // --- NOTES LOGIC ---
        const notesPanel = document.getElementById('notes-panel');
        const noteEditor = document.getElementById('note-editor');
        const saveStatus = document.getElementById('save-status');
        let saveTimeout;
        let syncInterval;
        let lastSavedContent = noteEditor.value;
        let isUserTyping = false;

        // Load preference - open if there's existing content or user preference
        if (localStorage.getItem('notesPanelOpen') === 'true' || noteEditor.value.trim() !== "") {
            notesPanel.classList.add('open');
            const btnNotes = document.getElementById('btn-notes');
            if (btnNotes) btnNotes.classList.add('active');
        }

        function toggleNotes() {
            const wasOpen = notesPanel.classList.contains('open');
            notesPanel.classList.toggle('open');
            localStorage.setItem('notesPanelOpen', notesPanel.classList.contains('open'));
            
            // Mise √† jour visuelle du bouton
            const btn = document.getElementById('btn-notes');
            if (btn) {
                if (notesPanel.classList.contains('open')) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            }
            
            // Start sync when opening, stop when closing
            if (!wasOpen && notesPanel.classList.contains('open')) {
                startSync();
            } else if (wasOpen) {
                stopSync();
            }
        }

        // Start sync when panel is already open on load
        if (notesPanel.classList.contains('open')) {
            startSync();
        }

        function startSync() {
            // Check for external changes every 2 seconds
            syncInterval = setInterval(checkForExternalChanges, 2000);
        }

        function stopSync() {
            if (syncInterval) {
                clearInterval(syncInterval);
                syncInterval = null;
            }
        }

        async function checkForExternalChanges() {
            // Don't sync if user is currently typing
            if (isUserTyping) return;
            
            try {
                const response = await fetch('/api/notes/{{ book_id }}/{{ chapter_index }}');
                if (response.ok) {
                    const data = await response.json();
                    const serverContent = data.content;
                    
                    // Only update if content changed and user hasn't modified locally
                    if (serverContent !== noteEditor.value && serverContent !== lastSavedContent) {
                        // External change detected
                        noteEditor.value = serverContent;
                        lastSavedContent = serverContent;
                        saveStatus.textContent = "Synced from Obsidian";
                        setTimeout(() => { saveStatus.textContent = "Synced"; }, 2000);
                    }
                }
            } catch (e) {
                console.error('Sync error:', e);
            }
        }

        noteEditor.addEventListener('input', () => {
            isUserTyping = true;
            saveStatus.textContent = "Typing...";
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                saveNotes();
                isUserTyping = false;
            }, 1000); // Autosave after 1s of inactivity
        });

        async function saveNotes() {
            saveStatus.textContent = "Saving...";
            const content = noteEditor.value;
            
            try {
                const response = await fetch('/api/notes/{{ book_id }}/{{ chapter_index }}', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: content })
                });
                
                if (response.ok) {
                    lastSavedContent = content;
                    saveStatus.textContent = "Saved to Obsidian";
                    saveStatus.style.color = "#999";
                    setTimeout(() => { saveStatus.textContent = "Synced"; }, 2000);
                } else {
                    saveStatus.textContent = "Error saving!";
                    saveStatus.style.color = "red";
                }
            } catch (e) {
                console.error(e);
                saveStatus.textContent = "Error saving!";
                saveStatus.style.color = "red";
            }
        }

        // --- MANUAL HIGHLIGHTER (RANGY) ---
        let highlighter;
        let highlightApplier;

        function initializeHighlighter() {
            if (typeof rangy === 'undefined' || !rangy.init) {
                console.warn('Rangy not loaded, manual highlighting disabled');
                return;
            }
            
            rangy.init();

            highlighter = rangy.createHighlighter();
            
            // Cr√©ation de la classe 'manual-highlight'
            highlightApplier = rangy.createClassApplier("manual-highlight", {
                ignoreWhiteSpace: true,
                tagNames: ["span"]
            });

            highlighter.addClassApplier(highlightApplier);
            
            const container = document.querySelector('.book-content');
            if (!container) return;

            // ACTION : Supprimer au clic droit
            container.addEventListener('mousedown', function(e) {
                // Bouton droit (2) sur un √©l√©ment d√©j√† surlign√©
                if (e.button === 2 && e.target.classList.contains('manual-highlight')) {
                    e.preventDefault(); // Emp√™che le menu contextuel
                    
                    const textToRemove = e.target.textContent.trim();
                    const elementToRemove = e.target;
                    
                    // R√©cup√®re l'objet "highlight" associ√© √† l'√©l√©ment DOM (si cr√©√© dans cette session)
                    const h = highlighter.getHighlightForElement(elementToRemove);
                    
                    if (h) {
                        // Cas 1: Highlight actif de la session (g√©r√© par Rangy Highlighter)
                        highlighter.removeHighlights([h]);
                    } else {
                        // Cas 2: Highlight charg√© depuis le serveur (HTML statique)
                        // On fait un "unwrap" manuel simple du DOM
                        const parent = elementToRemove.parentNode;
                        if (parent) {
                            // D√©placer tous les enfants du span avant le span lui-m√™me
                            while (elementToRemove.firstChild) {
                                parent.insertBefore(elementToRemove.firstChild, elementToRemove);
                            }
                            // Supprimer le span vide
                            parent.removeChild(elementToRemove);
                            // Normaliser pour fusionner les n≈ìuds de texte adjacents
                            parent.normalize();
                        }
                    }

                    // Supprimer c√¥t√© serveur
                    deleteManualHighlight(textToRemove);
                }
            });
        }

        // Appels API pour sauvegarder/supprimer les highlights manuels
        async function saveManualHighlight(text) {
            try {
                const response = await fetch('/api/highlights/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        book_id: "{{ book_id }}",
                        chapter_index: {{ chapter_index }},
                        text: text,
                        annotation: "Manuel"
                    })
                });
                if (!response.ok) {
                    console.error("Erreur sauvegarde highlight:", await response.text());
                }
            } catch (e) {
                console.error("Erreur lors de la sauvegarde du highlight:", e);
            }
        }

        async function deleteManualHighlight(text) {
            try {
                const response = await fetch('/api/highlights/remove', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        book_id: "{{ book_id }}",
                        chapter_index: {{ chapter_index }},
                        text: text
                    })
                });
                if (!response.ok) {
                    console.error("Erreur suppression highlight:", await response.text());
                }
            } catch (e) {
                console.error("Erreur lors de la suppression du highlight:", e);
            }
        }

        // Fonction pour surligner depuis le menu de s√©lection
        function highlightFromSelection() {
            if (!currentSelection || !currentSelection.text) return;
            
            // V√©rifier que Rangy est initialis√©
            if (typeof rangy === 'undefined' || !highlightApplier) {
                console.error('Rangy not initialized');
                return;
            }
            
            const text = currentSelection.text.trim();
            if (!text || text.length < 2) return;
            
            // Restaurer la s√©lection depuis le range sauvegard√©
            const selection = rangy.getSelection();
            selection.removeAllRanges();
            
            if (currentSelection.range) {
                try {
                    // Cloner le range pour √©viter les probl√®mes de r√©f√©rence
                    const clonedRange = currentSelection.range.cloneRange();
                    selection.addRange(clonedRange);
                } catch (e) {
                    console.error('Error restoring selection:', e);
                    // Si le range est invalide, on ne peut pas surligner
                    hideSelectionMenu();
                    return;
                }
            } else {
                console.error('No range stored in currentSelection');
                hideSelectionMenu();
                return;
            }
            
            // Appliquer le style visuel
            highlightApplier.applyToSelection();
            
            // D√©s√©lectionner pour la propret√©
            selection.removeAllRanges();
            
            // Sauvegarder c√¥t√© serveur
            saveManualHighlight(text);
            
            // Cacher le menu
            hideSelectionMenu();
        }

        // Lancer au chargement
        document.addEventListener('DOMContentLoaded', initializeHighlighter);
    </script>
</body>
</html>
