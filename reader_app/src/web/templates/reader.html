<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <style>
        /* Layout */
        body { margin: 0; padding: 0; display: flex; height: 100vh; overflow: hidden; font-family: "Georgia", serif; background: #fff; }

        /* Sidebar */
        #sidebar { width: 300px; background: #f8f9fa; border-right: 1px solid #e9ecef; overflow-y: auto; padding: 20px; flex-shrink: 0; }
        .nav-header { font-family: -apple-system, sans-serif; font-weight: bold; color: #495057; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #dee2e6; }
        .nav-home { display: block; margin-bottom: 20px; color: #3498db; text-decoration: none; font-family: -apple-system, sans-serif; font-size: 0.9em; }

        /* TOC Tree */
        ul.toc-list { list-style: none; padding-left: 0; margin: 0; }
        ul.toc-list ul { padding-left: 20px; } /* Indent children */
        li.toc-item { margin-bottom: 8px; }
        a.toc-link { text-decoration: none; color: #495057; font-size: 0.95em; display: block; padding: 4px 0; line-height: 1.4; }
        a.toc-link:hover { color: #000; text-decoration: underline; }
        a.toc-link.active { color: #d63384; font-weight: bold; }

        /* Main Content */
        #main { flex-grow: 1; overflow-y: auto; position: relative; scroll-behavior: smooth; }
        .content-container { max-width: 700px; margin: 0 auto; padding: 60px 40px; line-height: 1.8; font-size: 1.15em; color: #212529; }

        /* Panels Container */
        #panels-container {
            display: flex;
            flex-direction: row;
        }

        /* Note Panel */
        #notes-panel {
            width: 0;
            background: #fff;
            border-left: 1px solid #dee2e6;
            transition: width 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #notes-panel.open { width: 400px; }

        /* Chat Panel */
        #chat-panel {
            width: 0;
            background: #fff;
            border-left: 1px solid #dee2e6;
            transition: width 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #chat-panel.open { width: 400px; }
        
        .chat-header {
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            font-family: -apple-system, sans-serif;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .chat-message {
            max-width: 85%;
            padding: 12px 16px;
            border-radius: 12px;
            line-height: 1.5;
            word-wrap: break-word;
        }
        
        .chat-message.user-message {
            align-self: flex-end;
            background: #3498db;
            color: white;
        }
        
        .chat-message.assistant-message {
            align-self: flex-start;
            background: #f1f3f5;
            color: #212529;
        }
        
        .message-content {
            white-space: pre-wrap;
        }
        
        .chat-input-container {
            padding: 15px;
            border-top: 1px solid #dee2e6;
            background: #f8f9fa;
        }
        
        .chat-input-form {
            display: flex;
            gap: 8px;
        }
        
        .chat-input {
            flex-grow: 1;
            padding: 10px 15px;
            border: 1px solid #dee2e6;
            border-radius: 20px;
            font-family: -apple-system, sans-serif;
            font-size: 0.95em;
            outline: none;
        }
        
        .chat-input:focus {
            border-color: #3498db;
        }
        
        .chat-send-btn {
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-family: -apple-system, sans-serif;
            font-weight: bold;
        }
        
        .chat-send-btn:hover {
            background: #2980b9;
        }
        
        .chat-send-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .quote-indicator {
            padding: 8px 12px;
            background: #fff3cd;
            border-left: 3px solid #ffc107;
            margin-bottom: 10px;
            font-size: 0.9em;
            font-style: italic;
            border-radius: 4px;
        }
        
        .quote-indicator .remove-quote {
            float: right;
            cursor: pointer;
            font-weight: bold;
            color: #666;
        }
        
        .add-chapter-btn, .add-notes-btn {
            padding: 6px 12px;
            margin: 5px 0;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            font-family: -apple-system, sans-serif;
        }
        
        .add-chapter-btn:hover, .add-notes-btn:hover {
            background: #e9ecef;
        }
        
        .notes-header {
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            font-family: -apple-system, sans-serif;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .notes-editor {
            flex-grow: 1;
            padding: 20px;
            border: none;
            resize: none;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.5;
            outline: none;
        }
        
        .toggle-notes-btn, .toggle-chat-btn {
            position: fixed;
            top: 20px;
            z-index: 100;
            background: #fff;
            border: 1px solid #dee2e6;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-family: -apple-system, sans-serif;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .toggle-notes-btn {
            right: 20px;
        }
        .toggle-chat-btn {
            right: 140px;
        }
        .toggle-notes-btn:hover, .toggle-chat-btn:hover { background: #f8f9fa; }

        /* Content Styling (Basic normalization for the book HTML) */
        .book-content img { max-width: 100%; height: auto; display: block; margin: 20px auto; }
        .book-content h1, .book-content h2, .book-content h3 { font-family: -apple-system, sans-serif; margin-top: 1.5em; color: #333; }
        .book-content p { margin-bottom: 1.5em; text-align: justify; }
        
        /* Highlights */
        .book-content .highlight { 
            background-color: #fff3cd; 
            padding: 2px 0; 
            border-bottom: 2px solid #ffc107;
            cursor: help;
        }
        .book-content .highlight:hover {
            background-color: #ffe69c;
        }

        /* Navigation Footer */
        .chapter-nav { display: flex; justify-content: space-between; margin-top: 60px; padding-top: 20px; border-top: 1px solid #eee; font-family: -apple-system, sans-serif; }
        .nav-btn { text-decoration: none; color: #3498db; font-weight: bold; padding: 10px 20px; border: 1px solid #3498db; border-radius: 4px; transition: all 0.2s; }
        .nav-btn:hover { background: #3498db; color: white; }
        .nav-btn.disabled { opacity: 0.5; pointer-events: none; border-color: #ccc; color: #ccc; }

    </style>
</head>
<body>

    <!-- SIDEBAR -->
    <div id="sidebar">
        <a href="/" class="nav-home">‚Üê Back to Library</a>
        <div class="nav-header">{{ book.metadata.title }}</div>

        <!-- Recursive Macro for TOC -->
        {% macro render_toc(items) %}
            <ul class="toc-list">
            {% for item in items %}
                <li class="toc-item">
                    <!--
                        Matching Logic:
                        If the TOC item filename matches the current chapter filename, mark active.
                        Ideally we match spine indices, but Reader 3 TOC maps to filenames.
                        We use a simple hash matching logic here.
                    -->
                    {% set is_active = current_chapter.href == item.file_href %}

                    <!--
                       We need to find which linear chapter index (0, 1, 2) corresponds
                       to this TOC entry file.
                       Since that's hard to calculate in Jinja, we just link to the
                       file anchor. BUT, to make our linear navigation work, we
                       rely on the fact that the user is currently reading 'chapter_index'.

                       Ideally, clicking a TOC link should find the 'index' of that file.
                       For simplicity in this version: We link to the 'href' (filename)
                       and let JavaScript or Backend handle it?

                       Actually, let's just link to the file. The browser interprets #anchors.
                       However, our router uses /read/book/INDEX.

                       SIMPLE FIX: We won't link the TOC to the route index in this simple version
                       unless we build a map. We will visually show structure,
                       but rely on "Previous/Next" for linear reading.

                       BETTER FIX: Use JavaScript to match filenames.
                    -->
                    <a href="#" onclick="findAndGo('{{ item.file_href }}')"
                       class="toc-link {% if is_active %}active{% endif %}">
                        {{ item.title }}
                    </a>

                    {% if item.children %}
                        {{ render_toc(item.children) }}
                    {% endif %}
                </li>
            {% endfor %}
            </ul>
        {% endmacro %}

        {{ render_toc(book.toc) }}
    </div>

    <!-- MAIN CONTENT -->
    <div id="main">
        <button class="toggle-chat-btn" onclick="toggleChat()">üí¨ Chat</button>
        <button class="toggle-notes-btn" onclick="toggleNotes()">üìù Notes</button>
        
        <div class="content-container">
            <div class="book-content">
                {{ current_chapter.content | safe }}
            </div>

            <div class="chapter-nav">
                {% if prev_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ prev_idx }}" class="nav-btn">‚Üê Previous</a>
                {% else %}
                    <span class="nav-btn disabled">‚Üê Previous</span>
                {% endif %}

                <span style="color: #999; padding: 10px;">
                    Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                </span>

                {% if next_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ next_idx }}" class="nav-btn">Next ‚Üí</a>
                {% else %}
                    <span class="nav-btn disabled">Next ‚Üí</span>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- PANELS CONTAINER -->
    <div id="panels-container">
        <!-- CHAT PANEL -->
        <div id="chat-panel">
            <div class="chat-header">
                <span>Chat - {{ current_chapter.title }}</span>
            </div>
            <div class="chat-messages" id="chat-messages">
                <!-- Messages will be added here via HTMX -->
            </div>
            <div class="chat-input-container">
                <div id="quote-indicator" class="quote-indicator" style="display: none;">
                    <span id="quote-text"></span>
                    <span class="remove-quote" onclick="removeQuote()">√ó</span>
                </div>
                <div style="display: flex; gap: 5px; margin-bottom: 8px;">
                    <button class="add-chapter-btn" onclick="addChapterToContext()">+ Chapitre</button>
                    <button class="add-notes-btn" onclick="addNotesToContext()">+ Notes</button>
                </div>
                <form class="chat-input-form" 
                      onsubmit="return submitChatForm(event)">
                    <input type="text" 
                           id="chat-input" 
                           class="chat-input" 
                           placeholder="Pose une question sur ce chapitre..."
                           required>
                    <button type="submit" class="chat-send-btn">Envoyer</button>
                </form>
            </div>
        </div>

        <!-- NOTES PANEL -->
        <div id="notes-panel">
            <div class="notes-header">
                <span>Chapter Notes (Markdown)</span>
                <span id="save-status" style="font-size: 0.8em; color: #999;">Synced</span>
            </div>
            <textarea id="note-editor" class="notes-editor" placeholder="Write your notes here... they will sync to Obsidian.">{{ note_content }}</textarea>
        </div>
    </div>

    <script>
        // Helper to map TOC filenames to Spine Indices
        // Pass the spine data from python to JS
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ ch.order }},
            {% endfor %}
        };

        function findAndGo(filename) {
            // The TOC usually has specific filenames e.g. "text/part001.html"
            // Sometimes it has anchors "text/part001.html#header"
            // We strip the anchor to find the page index
            const cleanFile = filename.split('#')[0];
            const anchor = filename.split('#')[1];

            const idx = spineMap[cleanFile];

            if (idx !== undefined) {
                let url = "/read/{{ book_id }}/" + idx;
                // If there was an anchor, we could try to scroll to it,
                // but simple page loads often lose anchor position without extra JS.
                // Let's just go to the page.
                window.location.href = url;
            } else {
                console.log("Could not find index for", filename);
            }
        }

        // --- CHAT LOGIC ---
        const chatPanel = document.getElementById('chat-panel');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const quoteIndicator = document.getElementById('quote-indicator');
        const quoteText = document.getElementById('quote-text');
        // Note: quoted-text-input and conversation-history-input were removed from form
        // We use selectedText variable directly instead
        let conversationHistory = [];
        let selectedText = null;

        // Load chat preference
        if (localStorage.getItem('chatPanelOpen') === 'true') {
            chatPanel.classList.add('open');
        }

        function toggleChat() {
            const wasOpen = chatPanel.classList.contains('open');
            chatPanel.classList.toggle('open');
            localStorage.setItem('chatPanelOpen', chatPanel.classList.contains('open'));
            
            // Scroll to bottom when opening
            if (!wasOpen && chatPanel.classList.contains('open')) {
                setTimeout(() => scrollChatToBottom(), 100);
            }
        }

        function scrollChatToBottom() {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function clearChatInput() {
            if (chatInput) chatInput.value = '';
            removeQuote();
            scrollChatToBottom();
            // Note: updateConversationHistory() is called separately after messages are added
        }

        function removeQuote() {
            if (quoteIndicator) quoteIndicator.style.display = 'none';
            selectedText = null;
        }

        function addQuoteToChat(text) {
            selectedText = text;
            if (quoteText) quoteText.textContent = `"${text.substring(0, 100)}${text.length > 100 ? '...' : ''}"`;
            if (quoteIndicator) quoteIndicator.style.display = 'block';
        }

        function addChapterToContext() {
            const chapterText = document.querySelector('.book-content').innerText;
            if (chatInput.value.trim()) {
                chatInput.value = `[Contexte du chapitre]:\n\n${chapterText}\n\n---\n\n${chatInput.value}`;
            } else {
                chatInput.value = `[Contexte du chapitre]:\n\n${chapterText}`;
            }
            chatInput.focus();
        }

        function addNotesToContext() {
            const notesContent = noteEditor.value;
            if (notesContent.trim()) {
                if (chatInput.value.trim()) {
                    chatInput.value = `[Mes notes]:\n\n${notesContent}\n\n---\n\n${chatInput.value}`;
                } else {
                    chatInput.value = `[Mes notes]:\n\n${notesContent}`;
                }
                chatInput.focus();
            } else {
                alert('Vous n\'avez pas encore de notes pour ce chapitre.');
            }
        }

        function updateConversationHistory() {
            // Extract messages from the DOM
            const messages = chatMessages.querySelectorAll('.chat-message');
            conversationHistory = [];
            messages.forEach(msg => {
                const isUser = msg.classList.contains('user-message');
                const content = msg.querySelector('.message-content').textContent;
                conversationHistory.push({
                    role: isUser ? 'user' : 'assistant',
                    content: content
                });
            });
        }

        function submitChatForm(event) {
            event.preventDefault();
            const form = event.target;
            const message = chatInput.value.trim();
            if (!message) return false;

            // Prepare JSON body
            const body = {
                message: message,
                conversation_history: conversationHistory,
                quoted_text: selectedText || null
            };

            // Disable send button while processing
            const sendBtn = form.querySelector('button[type="submit"]');
            const originalBtnText = sendBtn.textContent;
            sendBtn.disabled = true;
            sendBtn.textContent = 'Envoi...';

            // Use fetch to send JSON
            // Encode parameters to handle special characters in book_id
            const bookId = encodeURIComponent('{{ book_id }}');
            const chapterIndex = encodeURIComponent('{{ chapter_index }}');
            
            fetch(`/chat/send?book_id=${bookId}&chapter_index=${chapterIndex}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        throw new Error(`Server error: ${response.status} - ${text}`);
                    });
                }
                return response.text();
            })
            .then(html => {
                console.log('Received HTML response:', html.substring(0, 200));
                
                // Create a temporary container to parse the HTML
                const temp = document.createElement('div');
                temp.innerHTML = html;
                
                // Append each message
                const messages = temp.querySelectorAll('.chat-message');
                console.log('Found messages:', messages.length);
                
                if (messages.length === 0) {
                    console.error('No messages found in response HTML');
                    alert('Erreur: Aucun message dans la r√©ponse du serveur');
                    return;
                }
                
                messages.forEach(msg => {
                    chatMessages.appendChild(msg.cloneNode(true));
                });
                
                // Handle OOB swaps (like note editor updates)
                const oobElements = temp.querySelectorAll('[hx-swap-oob]');
                oobElements.forEach(elem => {
                    const targetId = elem.id;
                    const target = document.getElementById(targetId);
                    if (target) {
                        target.value = elem.value;
                        // Trigger save if it's the note editor
                        if (targetId === 'note-editor') {
                            lastSavedContent = elem.value;
                            saveStatus.textContent = "Updated by AI";
                            setTimeout(() => { saveStatus.textContent = "Synced"; }, 2000);
                        }
                    }
                });
                
                // Update conversation history
                updateConversationHistory();
                
                // Clear input and scroll
                clearChatInput();
                
                // Re-enable send button
                sendBtn.disabled = false;
                sendBtn.textContent = originalBtnText;
            })
            .catch(error => {
                console.error('Chat error:', error);
                alert('Erreur lors de l\'envoi du message: ' + error.message);
                // Re-enable send button on error
                sendBtn.disabled = false;
                sendBtn.textContent = originalBtnText;
            });

            return false;
        }

        // Handle text selection for citation
        document.addEventListener('mouseup', () => {
            const selection = window.getSelection();
            const selectedTextContent = selection.toString().trim();
            
            if (selectedTextContent.length > 0 && selectedTextContent.length < 500) {
                // Show a small "Quote" button near the selection
                // For simplicity, we'll just store it and let user click a button
                // Or we can add a floating button
                selectedText = selectedTextContent;
            }
        });

        // Add keyboard shortcut to quote selected text (Ctrl+Q or Cmd+Q)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'q' && selectedText) {
                e.preventDefault();
                addQuoteToChat(selectedText);
                chatInput.focus();
            }
        });

        // Update conversation history when HTMX adds new messages
        document.body.addEventListener('htmx:afterSwap', (e) => {
            if (e.detail.target.id === 'chat-messages') {
                updateConversationHistory();
            }
        });

        // --- NOTES LOGIC ---
        const notesPanel = document.getElementById('notes-panel');
        const noteEditor = document.getElementById('note-editor');
        const saveStatus = document.getElementById('save-status');
        let saveTimeout;
        let syncInterval;
        let lastSavedContent = noteEditor.value;
        let isUserTyping = false;

        // Load preference - open if there's existing content or user preference
        if (localStorage.getItem('notesPanelOpen') === 'true' || noteEditor.value.trim() !== "") {
            notesPanel.classList.add('open');
        }

        function toggleNotes() {
            const wasOpen = notesPanel.classList.contains('open');
            notesPanel.classList.toggle('open');
            localStorage.setItem('notesPanelOpen', notesPanel.classList.contains('open'));
            
            // Start sync when opening, stop when closing
            if (!wasOpen && notesPanel.classList.contains('open')) {
                startSync();
            } else if (wasOpen) {
                stopSync();
            }
        }

        // Start sync when panel is already open on load
        if (notesPanel.classList.contains('open')) {
            startSync();
        }

        function startSync() {
            // Check for external changes every 2 seconds
            syncInterval = setInterval(checkForExternalChanges, 2000);
        }

        function stopSync() {
            if (syncInterval) {
                clearInterval(syncInterval);
                syncInterval = null;
            }
        }

        async function checkForExternalChanges() {
            // Don't sync if user is currently typing
            if (isUserTyping) return;
            
            try {
                const response = await fetch('/api/notes/{{ book_id }}/{{ chapter_index }}');
                if (response.ok) {
                    const data = await response.json();
                    const serverContent = data.content;
                    
                    // Only update if content changed and user hasn't modified locally
                    if (serverContent !== noteEditor.value && serverContent !== lastSavedContent) {
                        // External change detected
                        noteEditor.value = serverContent;
                        lastSavedContent = serverContent;
                        saveStatus.textContent = "Synced from Obsidian";
                        setTimeout(() => { saveStatus.textContent = "Synced"; }, 2000);
                    }
                }
            } catch (e) {
                console.error('Sync error:', e);
            }
        }

        noteEditor.addEventListener('input', () => {
            isUserTyping = true;
            saveStatus.textContent = "Typing...";
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                saveNotes();
                isUserTyping = false;
            }, 1000); // Autosave after 1s of inactivity
        });

        async function saveNotes() {
            saveStatus.textContent = "Saving...";
            const content = noteEditor.value;
            
            try {
                const response = await fetch('/api/notes/{{ book_id }}/{{ chapter_index }}', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: content })
                });
                
                if (response.ok) {
                    lastSavedContent = content;
                    saveStatus.textContent = "Saved to Obsidian";
                    saveStatus.style.color = "#999";
                    setTimeout(() => { saveStatus.textContent = "Synced"; }, 2000);
                } else {
                    saveStatus.textContent = "Error saving!";
                    saveStatus.style.color = "red";
                }
            } catch (e) {
                console.error(e);
                saveStatus.textContent = "Error saving!";
                saveStatus.style.color = "red";
            }
        }
    </script>
</body>
</html>
